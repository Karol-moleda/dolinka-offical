import { Image } from "./image";
import React, { useState, useEffect, useCallback, useRef } from "react";
import Masonry from 'react-masonry-css';
import './features.css';
import './gallery.css';

export const Gallery = (props) => {
  const [visibleImages, setVisibleImages] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);
  const [masonryKey, setMasonryKey] = useState(0); // Klucz do wymuszenia ponownego renderowania Masonry
  const imagesPerBatch = 12; // Liczba obrazów ładowanych w jednej partii
  const masonryRef = useRef(null); // Referencja do komponentu Masonry

  // Breakpointy dla układu Masonry
  const breakpointColumnsObj = {
    default: 3,
    1100: 2,
    700: 1
  };

  // Funkcja ładująca kolejną partię obrazów
  const loadMoreImages = useCallback(() => {
    if (props.data) {
      try {
        console.log("Ładowanie kolejnej partii obrazów:", visibleImages.length, "+", imagesPerBatch);
        const nextBatch = props.data.slice(0, visibleImages.length + imagesPerBatch);
        setVisibleImages(nextBatch);
        
        // Wymuszenie ponownego renderowania Masonry, aby poprawić układ
        setMasonryKey(prevKey => prevKey + 1);
        
        if (nextBatch.length >= props.data.length) {
          setLoading(false);
        }
      } catch (err) {
        console.error("Błąd podczas ładowania obrazów:", err);
        setError(true);
        setLoading(false);
      }
    }
  }, [props.data, visibleImages.length, imagesPerBatch]);

  // Inicjalne załadowanie pierwszej partii obrazów
  useEffect(() => {
    console.log("Inicjalizacja galerii z danymi:", props.data?.length || 0, "obrazów");
    
    if (props.data && props.data.length > 0) {
      // Sprawdź, czy dane obrazów są poprawne
      const validImages = props.data.filter(img => 
        img && img.smallImage && img.largeImage && 
        typeof img.smallImage === 'string' && 
        typeof img.largeImage === 'string'
      );
      
      if (validImages.length !== props.data.length) {
        console.warn(`Wykryto ${props.data.length - validImages.length} nieprawidłowych obrazów.`);
      }
      
      const initialBatchSize = Math.min(imagesPerBatch, props.data.length);
      console.log("Ładowanie początkowej partii:", initialBatchSize, "obrazów");
      
      setVisibleImages(props.data.slice(0, initialBatchSize));
      
      // Resetowanie klucza Masonry przy załadowaniu nowych danych
      setMasonryKey(prevKey => prevKey + 1);
      
      if (props.data.length <= initialBatchSize) {
        console.log("Wszystkie obrazy załadowane w pierwszej partii");
        setLoading(false);
      } else {
        // Automatycznie załaduj drugą partię po chwili
        setTimeout(() => {
          if (props.data.length > initialBatchSize) {
            console.log("Automatyczne ładowanie drugiej partii...");
            const secondBatchSize = Math.min(initialBatchSize + imagesPerBatch, props.data.length);
            setVisibleImages(props.data.slice(0, secondBatchSize));
            
            // Ponowne renderowanie Masonry przy załadowaniu kolejnej partii
            setMasonryKey(prevKey => prevKey + 1);
            
            if (secondBatchSize >= props.data.length) {
              setLoading(false);
            }
          }
        }, 1000);
      }
    }
  }, [props.data, imagesPerBatch]);
  
  // Obsługa zdarzenia scroll - ładowanie kolejnych obrazów przy przewijaniu
  useEffect(() => {
    const handleScroll = () => {
      // Sprawdzamy czy użytkownik doszedł do końca strony
      const scrollPosition = window.scrollY || window.pageYOffset;
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      
      // Poprawiony warunek sprawdzający, czy jesteśmy blisko końca strony
      if (
        scrollPosition + windowHeight >= documentHeight - 300 &&
        loading &&
        props.data && 
        visibleImages.length < props.data.length
      ) {
        console.log("Wykryto przewinięcie do końca strony, ładowanie więcej obrazów");
        loadMoreImages();
      }
    };

    window.addEventListener('scroll', handleScroll);
    
    // Wywołanie handleScroll po zamontowaniu, aby sprawdzić, czy trzeba od razu załadować więcej
    setTimeout(handleScroll, 500);
    
    return () => window.removeEventListener('scroll', handleScroll);
  }, [loading, loadMoreImages, props.data, visibleImages.length]);

  // Dodanie dodatkowego efektu, który wyrównuje układ Masonry po załadowaniu nowych obrazów
  useEffect(() => {
    // Wykorzystanie timeoutów do poprawy układu po renderowaniu
    if (visibleImages.length > 0) {
      const timer = setTimeout(() => {
        // Wymuszenie ponownego obliczenia układu przez przeglądarkę
        window.dispatchEvent(new Event('resize'));
        
        // Inkrementacja klucza Masonry aby wymusić ponowne renderowanie
        setMasonryKey(prevKey => prevKey + 1);
      }, 300);
      
      return () => clearTimeout(timer);
    }
  }, [visibleImages]);

  return (
    <div id="portfolio" className="text-center">
      <div className="container">
        <div className="section-title">
          <h2>Zdjęcia</h2>
          <p>
            Zarząd Osiedla Młodych w akcji – Zobacz, jak wspólnie działamy, organizujemy i bawimy się podczas naszych osiedlowych wydarzeń!
          </p>
        </div>
        <Masonry
          key={masonryKey} // Klucz do wymuszenia ponownego renderowania
          breakpointCols={breakpointColumnsObj}
          className="my-masonry-grid"
          columnClassName="my-masonry-grid_column"
          ref={masonryRef}
        >
          {visibleImages.map((d, i) => (
            <div key={`${d.title}-${i}`} className="gallery-item">
              <Image
                title={d.title}
                largeImage={d.largeImage}
                smallImage={d.smallImage}
              />
            </div>
          ))}
        </Masonry>
        
        {loading && props.data && props.data.length > 0 && (
          <div className="text-center mt-4 mb-4">
            <div className="spinner"></div>
            <p>Ładowanie więcej zdjęć...</p>
          </div>
        )}
        
        {/* Przycisk do ręcznego ładowania obrazów - tylko gdy są jeszcze niewyświetlone obrazy */}
        {props.data && (visibleImages.length < props.data.length) && (
          <div className="text-center mt-4 mb-4">
            <button 
              onClick={loadMoreImages} 
              className="load-more-btn"
            >
              Załaduj więcej zdjęć ({visibleImages.length} z {props.data.length})
            </button>
          </div>
        )}
        
        {error && (
          <div className="text-center mt-4 mb-4 error-message">
            <p>Wystąpił błąd podczas ładowania zdjęć. Spróbuj odświeżyć stronę lub kliknij przycisk "Załaduj więcej".</p>
          </div>
        )}
      </div>
    </div>
  );
};
